{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/staking/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint amount) external;\n\n    function approve(address spender, uint amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/zap/ISolidZapDecollateralize.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\n/// @author Solid World\ninterface ISolidZapDecollateralize {\n    event ZapDecollateralize(\n        address indexed receiver,\n        address indexed inputToken,\n        uint indexed inputAmount,\n        uint dust,\n        address dustRecipient,\n        uint categoryId\n    );\n\n    struct DecollateralizeParams {\n        uint[] batchIds;\n        uint[] amountsIn;\n        uint[] amountsOutMin;\n    }\n\n    function router() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function swManager() external view returns (address);\n\n    function forwardContractBatch() external view returns (address);\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Swaps `inputToken` to `crispToken` via encoded swap\n    /// 2. Decollateralizes resulting tokens to forward credits via SolidWorldManager\n    /// 3. Transfers resulting forward credits to `msg.sender`\n    /// 4. Transfers remaining crisp token balance of SolidZapDecollateralize to the `dustRecipient`\n    /// 5. Transfers any remaining input token balance of SolidZapDecollateralize to `msg.sender`\n    /// @notice The `msg.sender` must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @param inputToken The token used for redeeming forward credits\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param crispToken The intermediate token used for redeeming forward credits\n    /// @param swap Encoded swap from `inputToken` to `crispToken`\n    /// @param dustRecipient Address to receive any remaining crisp tokens dust\n    /// @param decollateralizeParams Parameters for decollateralization\n    ///  batchIds The batch ids of the forward credits to redeem\n    ///  amountsIn The amounts of `crispToken` to used to redeem forward credits\n    ///  amountsOutMin The minimum amounts of forward credits to receive\n    function zapDecollateralize(\n        address inputToken,\n        uint inputAmount,\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams\n    ) external;\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Swaps `inputToken` to `crispToken` via encoded swap\n    /// 2. Decollateralizes resulting tokens to forward credits via SolidWorldManager\n    /// 3. Transfers resulting forward credits to `zapRecipient`\n    /// 4. Transfers remaining crisp token balance of SolidZapDecollateralize to the `dustRecipient`\n    /// 5. Transfers any remaining input token balance of SolidZapDecollateralize to `zapRecipient`\n    /// @notice The msg.sender must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @param inputToken The token used for redeeming forward credits\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param crispToken The intermediate token used for redeeming forward credits\n    /// @param swap Encoded swap from `inputToken` to `crispToken`\n    /// @param dustRecipient Address to receive any remaining crisp tokens dust\n    /// @param decollateralizeParams Parameters for decollateralization\n    ///  batchIds The batch ids of the forward credits to redeem\n    ///  amountsIn The amounts of `crispToken` to used to redeem forward credits\n    ///  amountsOutMin The minimum amounts of forward credits to receive\n    /// @param zapRecipient The address to receive forward credits\n    function zapDecollateralize(\n        address inputToken,\n        uint inputAmount,\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams,\n        address zapRecipient\n    ) external;\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Wraps `msg.value` to WETH\n    /// 2. Swaps `WETH` to `crispToken` via encoded swap\n    /// 3. Decollateralizes resulting tokens to forward credits via SolidWorldManager\n    /// 4. Transfers resulting forward credits to `msg.sender`\n    /// 5. Transfers remaining crisp token balance of SolidZapDecollateralize to the `dustRecipient`\n    /// 6. Withdraws any remaining WETH balance of SolidZapDecollateralize and transfers the ETH to `msg.sender`\n    /// @param crispToken The intermediate token used for redeeming forward credits\n    /// @param swap Encoded swap from `inputToken` to `crispToken`\n    /// @param dustRecipient Address to receive any remaining crisp tokens dust\n    /// @param decollateralizeParams Parameters for decollateralization\n    ///  batchIds The batch ids of the forward credits to redeem\n    ///  amountsIn The amounts of `crispToken` to used to redeem forward credits\n    ///  amountsOutMin The minimum amounts of forward credits to receive\n    function zapDecollateralizeETH(\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams\n    ) external payable;\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Wraps `msg.value` to WETH\n    /// 2. Swaps `WETH` to `crispToken` via encoded swap\n    /// 3. Decollateralizes resulting tokens to forward credits via SolidWorldManager\n    /// 4. Transfers resulting forward credits to `zapRecipient`\n    /// 5. Transfers remaining crisp token balance of SolidZapDecollateralize to the `dustRecipient`\n    /// 6. Withdraws any remaining WETH balance of SolidZapDecollateralize and transfers the ETH to `zapRecipient`\n    /// @param crispToken The intermediate token used for redeeming forward credits\n    /// @param swap Encoded swap from `inputToken` to `crispToken`\n    /// @param dustRecipient Address to receive any remaining crisp tokens dust\n    /// @param decollateralizeParams Parameters for decollateralization\n    ///  batchIds The batch ids of the forward credits to redeem\n    ///  amountsIn The amounts of `crispToken` to used to redeem forward credits\n    ///  amountsOutMin The minimum amounts of forward credits to receive\n    /// @param zapRecipient The address to receive forward credits\n    function zapDecollateralizeETH(\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams,\n        address zapRecipient\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/zap/ISolidZapStaker.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\n/// @author Solid World\ninterface ISolidZapStaker {\n    error AcquiredSharesLessThanMin(uint acquired, uint min);\n    error InvalidSwap();\n\n    event ZapStake(\n        address indexed zapRecipient,\n        address indexed inputToken,\n        uint indexed inputAmount,\n        uint shares\n    );\n\n    struct Fraction {\n        uint numerator;\n        uint denominator;\n    }\n\n    struct SwapResult {\n        address _address;\n        uint balance;\n    }\n\n    struct SwapResults {\n        SwapResult token0;\n        SwapResult token1;\n    }\n\n    function router() external view returns (address);\n\n    function weth() external view returns (address);\n\n    function solidStaking() external view returns (address);\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Partially swaps `inputToken` to desired token via encoded swap1\n    /// 2. Partially swaps `inputToken` to desired token via encoded swap2\n    /// 3. Resulting tokens are deployed as liquidity via IUniProxy & `hypervisor`\n    /// 4. Shares of the deployed liquidity are staked in `solidStaking`. `zapRecipient` is the beneficiary of the staked shares\n    /// @notice The msg.sender must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @param inputToken The token used to provide liquidity\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap1 Encoded swap to partially swap `inputToken` to desired token\n    /// @param swap2 Encoded swap to partially swap `inputToken` to desired token\n    /// @param minShares The minimum amount of liquidity shares required for transaction to succeed\n    /// @param zapRecipient The beneficiary of the staked shares\n    /// @return shares The amount of shares staked in `solidStaking`\n    function stakeDoubleSwap(\n        address inputToken,\n        uint inputAmount,\n        address hypervisor,\n        bytes calldata swap1,\n        bytes calldata swap2,\n        uint minShares,\n        address zapRecipient\n    ) external returns (uint shares);\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Partially swaps `inputToken` to desired token via encoded swap1\n    /// 2. Partially swaps `inputToken` to desired token via encoded swap2\n    /// 3. Resulting tokens are deployed as liquidity via IUniProxy & `hypervisor`\n    /// 4. Shares of the deployed liquidity are staked in `solidStaking`. `msg.sender` is the beneficiary of the staked shares\n    /// @notice The msg.sender must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @param inputToken The token used to provide liquidity\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap1 Encoded swap to partially swap `inputToken` to desired token\n    /// @param swap2 Encoded swap to partially swap `inputToken` to desired token\n    /// @param minShares The minimum amount of liquidity shares required for transaction to succeed\n    /// @return shares The amount of shares staked in `solidStaking`\n    function stakeDoubleSwap(\n        address inputToken,\n        uint inputAmount,\n        address hypervisor,\n        bytes calldata swap1,\n        bytes calldata swap2,\n        uint minShares\n    ) external returns (uint shares);\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Partially (close to 50%) swaps `inputToken` to desired token via encoded swap\n    /// 3. Resulting tokens are deployed as liquidity via IUniProxy & `hypervisor`\n    /// 4. Shares of the deployed liquidity are staked in `solidStaking`. `zapRecipient` is the beneficiary of the staked shares\n    /// @notice The msg.sender must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @notice `inputToken` must be one of hypervisor's token0 or token1\n    /// @param inputToken The token used to provide liquidity\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap Encoded swap to partially swap `inputToken` to desired token\n    /// @param minShares The minimum amount of liquidity shares required for transaction to succeed\n    /// @param zapRecipient The beneficiary of the staked shares\n    /// @return shares The amount of shares staked in `solidStaking`\n    function stakeSingleSwap(\n        address inputToken,\n        uint inputAmount,\n        address hypervisor,\n        bytes calldata swap,\n        uint minShares,\n        address zapRecipient\n    ) external returns (uint shares);\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Partially (close to 50%) swaps `inputToken` to desired token via encoded swap\n    /// 3. Resulting tokens are deployed as liquidity via IUniProxy & `hypervisor`\n    /// 4. Shares of the deployed liquidity are staked in `solidStaking`. `msg.sender` is the beneficiary of the staked shares\n    /// @notice The msg.sender must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @notice `inputToken` must be one of hypervisor's token0 or token1\n    /// @param inputToken The token used to provide liquidity\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap Encoded swap to partially swap `inputToken` to desired token\n    /// @param minShares The minimum amount of liquidity shares required for transaction to succeed\n    /// @return shares The amount of shares staked in `solidStaking`\n    function stakeSingleSwap(\n        address inputToken,\n        uint inputAmount,\n        address hypervisor,\n        bytes calldata swap,\n        uint minShares\n    ) external returns (uint shares);\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Wraps `msg.value` to WETH\n    /// 2. Partially swaps `WETH` to desired token via encoded swap1\n    /// 3. Partially swaps `WETH` to desired token via encoded swap2\n    /// 4. Resulting tokens are deployed as liquidity via IUniProxy & `hypervisor`\n    /// 5. Shares of the deployed liquidity are staked in `solidStaking`. `zapRecipient` is the beneficiary of the staked shares\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap1 Encoded swap to partially swap `WETH` to desired token\n    /// @param swap2 Encoded swap to partially swap `WETH` to desired token\n    /// @param minShares The minimum amount of liquidity shares required for transaction to succeed\n    /// @param zapRecipient The beneficiary of the staked shares\n    /// @return shares The amount of shares staked in `solidStaking`\n    function stakeETH(\n        address hypervisor,\n        bytes calldata swap1,\n        bytes calldata swap2,\n        uint minShares,\n        address zapRecipient\n    ) external payable returns (uint shares);\n\n    /// @notice Zap function that achieves the following:\n    /// 1. Wraps `msg.value` to WETH\n    /// 2. Partially swaps `WETH` to desired token via encoded swap1\n    /// 3. Partially swaps `WETH` to desired token via encoded swap2\n    /// 4. Resulting tokens are deployed as liquidity via IUniProxy & `hypervisor`\n    /// 5. Shares of the deployed liquidity are staked in `solidStaking`. `msg.sender` is the beneficiary of the staked shares\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap1 Encoded swap to partially swap `WETH` to desired token\n    /// @param swap2 Encoded swap to partially swap `WETH` to desired token\n    /// @param minShares The minimum amount of liquidity shares required for transaction to succeed\n    /// @return shares The amount of shares staked in `solidStaking`\n    function stakeETH(\n        address hypervisor,\n        bytes calldata swap1,\n        bytes calldata swap2,\n        uint minShares\n    ) external payable returns (uint shares);\n\n    /// @notice Function is meant to be called off-chain with _staticCall_.\n    /// @notice Zap function that achieves the following:\n    /// 1. Partially swaps `inputToken` to desired token via encoded swap1\n    /// 2. Partially swaps `inputToken` to desired token via encoded swap2\n    /// 3. Resulting tokens are checked against Gamma Vault to determine if they qualify for a dustless liquidity deployment\n    ///     * if dustless, the function deploys the liquidity to obtain the amounts of shares getting minted and returns\n    ///     * if not dustless, the function computes the current gamma token ratio and returns\n    /// @notice The msg.sender must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @param inputToken The token used to provide liquidity\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap1 Encoded swap to partially swap `inputToken` to desired token\n    /// @param swap2 Encoded swap to partially swap `inputToken` to desired token\n    /// @return isDustless Whether the resulting tokens qualify for a dustless liquidity deployment\n    /// @return shares The amount of shares minted from the dustless liquidity deployment\n    /// @return ratio The current gamma token ratio, or empty if dustless\n    function simulateStakeDoubleSwap(\n        address inputToken,\n        uint inputAmount,\n        address hypervisor,\n        bytes calldata swap1,\n        bytes calldata swap2\n    )\n        external\n        returns (\n            bool isDustless,\n            uint shares,\n            Fraction memory ratio\n        );\n\n    /// @notice Function is meant to be called off-chain with _staticCall_.\n    /// @notice Zap function that achieves the following:\n    /// 1. Wraps `msg.value` to WETH\n    /// 2. Partially swaps `WETH` to desired token via encoded swap1\n    /// 3. Partially swaps `WETH` to desired token via encoded swap2\n    /// 4. Resulting tokens are checked against Gamma Vault to determine if they qualify for a dustless liquidity deployment\n    ///     * if dustless, the function deploys the liquidity to obtain the amounts of shares getting minted and returns\n    ///     * if not dustless, the function computes the current gamma token ratio and returns\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap1 Encoded swap to partially swap `WETH` to desired token\n    /// @param swap2 Encoded swap to partially swap `WETH` to desired token\n    /// @return isDustless Whether the resulting tokens qualify for a dustless liquidity deployment\n    /// @return shares The amount of shares minted from the dustless liquidity deployment\n    /// @return ratio The current gamma token ratio, or empty if dustless\n    function simulateStakeETH(\n        address hypervisor,\n        bytes calldata swap1,\n        bytes calldata swap2\n    )\n        external\n        payable\n        returns (\n            bool isDustless,\n            uint shares,\n            Fraction memory ratio\n        );\n\n    /// @notice Function is meant to be called off-chain with _staticCall_.\n    /// @notice Zap function that achieves the following:\n    /// 1. Partially (close to 50%) swaps `inputToken` to desired token via encoded swap\n    /// 2. Resulting tokens are checked against Gamma Vault to determine if they qualify for a dustless liquidity deployment\n    ///     * if dustless, the function deploys the liquidity to obtain the amounts of shares getting minted and returns\n    ///     * if not dustless, the function computes the current gamma token ratio and returns\n    /// @notice The msg.sender must own `inputAmount` and approve this contract to spend `inputToken`\n    /// @notice `inputToken` must be one of hypervisor's token0 or token1\n    /// @param inputToken The token used to provide liquidity\n    /// @param inputAmount The amount of `inputToken` to use\n    /// @param hypervisor The hypervisor used to deploy liquidity\n    /// @param swap Encoded swap to partially (close to 50%) swap `inputToken` to desired token\n    /// @return isDustless Whether the resulting tokens qualify for a dustless liquidity deployment\n    /// @return shares The amount of shares minted from the dustless liquidity deployment\n    /// @return ratio The current gamma token ratio, or empty if dustless\n    function simulateStakeSingleSwap(\n        address inputToken,\n        uint inputAmount,\n        address hypervisor,\n        bytes calldata swap\n    )\n        external\n        returns (\n            bool isDustless,\n            uint shares,\n            Fraction memory ratio\n        );\n}\n"
    },
    "contracts/interfaces/zap/ISWManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\n/// @author Solid World\n/// @dev The minimal interface used to interact with SolidWorldManager\ninterface ISWManager {\n    function collateralizeBatch(\n        uint batchId,\n        uint amountIn,\n        uint amountOutMin\n    ) external;\n\n    function bulkDecollateralizeTokens(\n        uint[] calldata batchIds,\n        uint[] calldata amountsIn,\n        uint[] calldata amountsOutMin\n    ) external;\n\n    function getBatchCategory(uint batchId) external view returns (uint);\n}\n"
    },
    "contracts/libraries/GPv2SafeERC20_0_8_18.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\nlibrary GPv2SafeERC20 {\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n    /// also when the token returns `false`.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transfer.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freeMemoryPointer, 36), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"GPv2: failed transfer\");\n    }\n\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n    /// reverts also when the token returns `false`.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transferFrom.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n            mstore(add(freeMemoryPointer, 68), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTransferResult(token), \"GPv2: failed transferFrom\");\n    }\n\n    /// @dev Verifies that the last return was a successful `transfer*` call.\n    /// This is done by checking that the return data is either empty, or\n    /// is a valid ABI encoded boolean.\n    function getLastTransferResult(IERC20 token) private view returns (bool success) {\n        // NOTE: Inspecting previous return data requires assembly. Note that\n        // we write the return data to memory 0 in the case where the return\n        // data size is 32, this is OK since the first 64 bytes of memory are\n        // reserved by Solidy as a scratch space that can be used within\n        // assembly blocks.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            /// @dev Revert with an ABI encoded Solidity error with a message\n            /// that fits into 32-bytes.\n            ///\n            /// An ABI encoded Solidity error has the following memory layout:\n            ///\n            /// ------------+----------------------------------\n            ///  byte range | value\n            /// ------------+----------------------------------\n            ///  0x00..0x04 |        selector(\"Error(string)\")\n            ///  0x04..0x24 |      string offset (always 0x20)\n            ///  0x24..0x44 |                    string length\n            ///  0x44..0x64 | string value, padded to 32-bytes\n            function revertWithMessage(length, message) {\n                mstore(0x00, \"\\x08\\xc3\\x79\\xa0\")\n                mstore(0x04, 0x20)\n                mstore(0x24, length)\n                mstore(0x44, message)\n                revert(0x00, 0x64)\n            }\n\n            switch returndatasize()\n            // Non-standard ERC20 transfer without return.\n            case 0 {\n                // NOTE: When the return data size is 0, verify that there\n                // is code at the address. This is done in order to maintain\n                // compatibility with Solidity calling conventions.\n                // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\n                if iszero(extcodesize(token)) {\n                    revertWithMessage(20, \"GPv2: not a contract\")\n                }\n\n                success := 1\n            }\n            // Standard ERC20 transfer returning boolean success value.\n            case 32 {\n                returndatacopy(0, 0, returndatasize())\n\n                // NOTE: For ABI encoding v1, any non-zero value is accepted\n                // as `true` for a boolean. In order to stay compatible with\n                // OpenZeppelin's `SafeERC20` library which is known to work\n                // with the existing ERC20 implementation we care about,\n                // make sure we return success for any non-zero return value\n                // from the `transfer*` call.\n                success := iszero(iszero(mload(0)))\n            }\n            default {\n                revertWithMessage(31, \"GPv2: malformed transfer result\")\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Simply use address for `token` parameter\nlibrary SafeTransferLib {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/zap/BaseZap.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/staking/IWETH.sol\";\nimport \"../interfaces/zap/ISolidZapStaker.sol\";\nimport \"../interfaces/zap/ISWManager.sol\";\nimport \"../libraries/GPv2SafeERC20_0_8_18.sol\";\nimport \"../libraries/SafeTransferLib.sol\";\n\n/// @author Solid World\nabstract contract BaseZap {\n    using GPv2SafeERC20 for IERC20;\n    using SafeTransferLib for address;\n\n    error GenericSwapError();\n    error InvalidInput();\n    error SweepAmountZero();\n    error ETHTransferFailed();\n\n    function _swapViaRouter(address router, bytes calldata encodedSwap) internal {\n        (bool success, bytes memory retData) = router.call(encodedSwap);\n\n        if (!success) {\n            _propagateError(retData);\n        }\n    }\n\n    function _propagateError(bytes memory revertReason) internal pure {\n        if (revertReason.length == 0) {\n            revert GenericSwapError();\n        }\n\n        assembly {\n            revert(add(32, revertReason), mload(revertReason))\n        }\n    }\n\n    function _wrap(address weth, uint amount) internal {\n        IWETH(weth).deposit{ value: amount }();\n    }\n\n    function _approveTokenSpendingIfNeeded(address token, address spender) internal {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            token.safeApprove(spender, type(uint).max);\n        }\n    }\n\n    function _prepareToSwap(\n        address inputToken,\n        uint inputAmount,\n        address _router\n    ) internal {\n        IERC20(inputToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        _approveTokenSpendingIfNeeded(inputToken, _router);\n    }\n\n    function _sweepTokens(address token, address recipient) internal returns (uint sweptAmount) {\n        sweptAmount = _safeSweepTokens(token, recipient, false);\n    }\n\n    function _safeSweepTokens(\n        address token,\n        address recipient,\n        bool revertOnSweepAmountZero\n    ) internal returns (uint sweptAmount) {\n        sweptAmount = IERC20(token).balanceOf(address(this));\n        if (sweptAmount == 0 && revertOnSweepAmountZero) {\n            revert SweepAmountZero();\n        }\n\n        if (sweptAmount > 0) {\n            IERC20(token).safeTransfer(recipient, sweptAmount);\n        }\n    }\n\n    function _sweepETH(address weth, address recipient) internal returns (uint sweptAmount) {\n        sweptAmount = _safeSweepETH(weth, recipient, false);\n    }\n\n    function _safeSweepETH(\n        address weth,\n        address recipient,\n        bool revertOnSweepAmountZero\n    ) internal returns (uint sweptAmount) {\n        sweptAmount = IERC20(weth).balanceOf(address(this));\n        if (sweptAmount == 0 && revertOnSweepAmountZero) {\n            revert SweepAmountZero();\n        }\n\n        if (sweptAmount > 0) {\n            IWETH(weth).withdraw(sweptAmount);\n            (bool success, ) = payable(recipient).call{ value: sweptAmount }(\"\");\n            if (!success) {\n                revert ETHTransferFailed();\n            }\n        }\n    }\n}\n"
    },
    "contracts/zap/decollateralize/BaseSolidZapDecollateralize.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"../../interfaces/zap/ISolidZapDecollateralize.sol\";\nimport \"../../interfaces/staking/IWETH.sol\";\nimport \"../BaseZap.sol\";\n\n/// @author Solid World\nabstract contract BaseSolidZapDecollateralize is\n    BaseZap,\n    ISolidZapDecollateralize,\n    IERC1155Receiver,\n    ReentrancyGuard\n{\n    address public immutable router;\n    address public immutable weth;\n    address public immutable swManager;\n    address public immutable forwardContractBatch;\n\n    constructor(\n        address _router,\n        address _weth,\n        address _swManager,\n        address _forwardContractBatch\n    ) {\n        router = _router;\n        weth = _weth;\n        swManager = _swManager;\n        forwardContractBatch = _forwardContractBatch;\n\n        IWETH(weth).approve(_router, type(uint).max);\n    }\n\n    /// @dev accept transfers from swManager contract only\n    function onERC1155Received(\n        address operator,\n        address,\n        uint,\n        uint,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        if (operator != swManager) {\n            return bytes4(0);\n        }\n\n        return this.onERC1155Received.selector;\n    }\n\n    /// @dev accept transfers from swManager contract only\n    function onERC1155BatchReceived(\n        address operator,\n        address,\n        uint[] memory,\n        uint[] memory,\n        bytes memory\n    ) public virtual returns (bytes4) {\n        if (operator != swManager) {\n            return bytes4(0);\n        }\n\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {\n        // ERC165 && ERC1155TokenReceiver support\n        return interfaceId == 0x01ffc9a7 || interfaceId == 0x4e2312e0;\n    }\n\n    receive() external payable {\n        if (msg.sender != weth) {\n            revert ETHTransferFailed();\n        }\n    }\n\n    fallback() external payable {\n        if (msg.sender != weth) {\n            revert ETHTransferFailed();\n        }\n    }\n}\n"
    },
    "contracts/zap/decollateralize/SolidZapDecollateralize.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.18;\n\nimport \"./BaseSolidZapDecollateralize.sol\";\n\n/// @author Solid World\ncontract SolidZapDecollateralize is BaseSolidZapDecollateralize {\n    using GPv2SafeERC20 for IERC20;\n\n    constructor(\n        address _router,\n        address _weth,\n        address _swManager,\n        address _forwardContractBatch\n    ) BaseSolidZapDecollateralize(_router, _weth, _swManager, _forwardContractBatch) {}\n\n    /// @inheritdoc ISolidZapDecollateralize\n    function zapDecollateralize(\n        address inputToken,\n        uint inputAmount,\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams\n    ) external nonReentrant {\n        _prepareToSwap(inputToken, inputAmount, router);\n        _zapDecollateralize(\n            inputToken,\n            inputAmount,\n            crispToken,\n            swap,\n            dustRecipient,\n            decollateralizeParams,\n            msg.sender,\n            _sweepTokens\n        );\n    }\n\n    /// @inheritdoc ISolidZapDecollateralize\n    function zapDecollateralize(\n        address inputToken,\n        uint inputAmount,\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams,\n        address zapRecipient\n    ) external nonReentrant {\n        _prepareToSwap(inputToken, inputAmount, router);\n        _zapDecollateralize(\n            inputToken,\n            inputAmount,\n            crispToken,\n            swap,\n            dustRecipient,\n            decollateralizeParams,\n            zapRecipient,\n            _sweepTokens\n        );\n    }\n\n    /// @inheritdoc ISolidZapDecollateralize\n    function zapDecollateralizeETH(\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams\n    ) external payable nonReentrant {\n        _wrap(weth, msg.value);\n        _zapDecollateralize(\n            weth,\n            msg.value,\n            crispToken,\n            swap,\n            dustRecipient,\n            decollateralizeParams,\n            msg.sender,\n            _sweepETH\n        );\n    }\n\n    /// @inheritdoc ISolidZapDecollateralize\n    function zapDecollateralizeETH(\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams,\n        address zapRecipient\n    ) external payable nonReentrant {\n        _wrap(weth, msg.value);\n        _zapDecollateralize(\n            weth,\n            msg.value,\n            crispToken,\n            swap,\n            dustRecipient,\n            decollateralizeParams,\n            zapRecipient,\n            _sweepETH\n        );\n    }\n\n    function _zapDecollateralize(\n        address inputToken,\n        uint inputAmount,\n        address crispToken,\n        bytes calldata swap,\n        address dustRecipient,\n        DecollateralizeParams calldata decollateralizeParams,\n        address zapRecipient,\n        function(address, address) returns (uint) sweepUnspentTokens\n    ) private {\n        _swapViaRouter(router, swap);\n        _approveTokenSpendingIfNeeded(crispToken, swManager);\n        ISWManager(swManager).bulkDecollateralizeTokens(\n            decollateralizeParams.batchIds,\n            decollateralizeParams.amountsIn,\n            decollateralizeParams.amountsOutMin\n        );\n        IERC1155(forwardContractBatch).safeBatchTransferFrom(\n            address(this),\n            zapRecipient,\n            decollateralizeParams.batchIds,\n            _getDecollateralizedForwardCreditAmounts(decollateralizeParams.batchIds),\n            \"\"\n        );\n        uint dustAmount = _sweepTokens(crispToken, dustRecipient);\n        sweepUnspentTokens(inputToken, zapRecipient);\n        uint categoryId = ISWManager(swManager).getBatchCategory(decollateralizeParams.batchIds[0]);\n\n        emit ZapDecollateralize(zapRecipient, inputToken, inputAmount, dustAmount, dustRecipient, categoryId);\n    }\n\n    function _getDecollateralizedForwardCreditAmounts(uint[] calldata batchIds)\n        private\n        view\n        returns (uint[] memory decollateralizedForwardCreditAmounts)\n    {\n        address[] memory addresses = new address[](batchIds.length);\n        for (uint i; i < batchIds.length; i++) {\n            addresses[i] = address(this);\n        }\n        decollateralizedForwardCreditAmounts = IERC1155(forwardContractBatch).balanceOfBatch(\n            addresses,\n            batchIds\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}